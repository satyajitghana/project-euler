{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Euler - Home # Hey \ud83d\udc4b there, This is the documentation for my cute little project euler solutions repository, i'll try to update the repository with my solutions and maybe even try to explain my solutions. Please use the search bar to search your problem number or the title of the problem Head over to Solutions ! Happy Coding \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb My Progress #","title":"Project Euler - Home"},{"location":"#project-euler-home","text":"Hey \ud83d\udc4b there, This is the documentation for my cute little project euler solutions repository, i'll try to update the repository with my solutions and maybe even try to explain my solutions. Please use the search bar to search your problem number or the title of the problem Head over to Solutions ! Happy Coding \ud83d\udc69\u200d\ud83d\udcbb\ud83d\udc68\u200d\ud83d\udcbb","title":"Project Euler - Home"},{"location":"#my-progress","text":"","title":"My Progress"},{"location":"about/","text":"About # \"Project Euler exists to encourage, challenge, and develop the skills and enjoyment of anyone with an interest in the fascinating world of mathematics.\"","title":"About"},{"location":"about/#about","text":"\"Project Euler exists to encourage, challenge, and develop the skills and enjoyment of anyone with an interest in the fascinating world of mathematics.\"","title":"About"},{"location":"solutions/","text":"Solutions # Problem 001 # Problem 018 # Problem 020 # Problem 023 # Problem 025 #","title":"Solutions"},{"location":"solutions/#solutions","text":"","title":"Solutions"},{"location":"solutions/#problem-001","text":"","title":"Problem 001"},{"location":"solutions/#problem-018","text":"","title":"Problem 018"},{"location":"solutions/#problem-020","text":"","title":"Problem 020"},{"location":"solutions/#problem-023","text":"","title":"Problem 023"},{"location":"solutions/#problem-025","text":"","title":"Problem 025"},{"location":"problem-001/","text":"Multiples of 3 and 5 # #include<bits/stdc++.h> int main() { int sum = 0; for (int i = 1 ; i < 1000 ; i++) { if (i % 3 == 0 || i % 5 == 0) { sum += i; } } printf(\"%d\\n\", sum); return 0; } OUTPUT 233168","title":"Multiples of 3 and 5"},{"location":"problem-001/#multiples-of-3-and-5","text":"#include<bits/stdc++.h> int main() { int sum = 0; for (int i = 1 ; i < 1000 ; i++) { if (i % 3 == 0 || i % 5 == 0) { sum += i; } } printf(\"%d\\n\", sum); return 0; } OUTPUT 233168","title":"Multiples of 3 and 5"},{"location":"problem-002/","text":"Even Fibonacci numbers # def solution(): x = 1 # Represents the current Fibonacci number being processed y = 2 # Represents the next Fibonacci number in the sequence ans = 0 while x <= 4000000: if x % 2 == 0: ans += x x, y = y, x + y return ans OUTPUT 4613732","title":"Even Fibonacci numbers"},{"location":"problem-002/#even-fibonacci-numbers","text":"def solution(): x = 1 # Represents the current Fibonacci number being processed y = 2 # Represents the next Fibonacci number in the sequence ans = 0 while x <= 4000000: if x % 2 == 0: ans += x x, y = y, x + y return ans OUTPUT 4613732","title":"Even Fibonacci numbers"},{"location":"problem-003/","text":"Largest prime facror of 600851475143 # import math def prime_factors(n): result = [0] while n % 2 == 0: result.append[2] n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: result.append(i) n = n / i if n > 2: result.append(n) return result[-1] n = int(input()) print(prime_factors(n)) INPUT 600851475143 OUTPUT 6857","title":"Largest prime facror of 600851475143"},{"location":"problem-003/#largest-prime-facror-of-600851475143","text":"import math def prime_factors(n): result = [0] while n % 2 == 0: result.append[2] n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: result.append(i) n = n / i if n > 2: result.append(n) return result[-1] n = int(input()) print(prime_factors(n)) INPUT 600851475143 OUTPUT 6857","title":"Largest prime facror of 600851475143"},{"location":"problem-005/","text":"Smallest number evenly divisible by numbers from 1 to 20 # import math def divisible_from_1_to_n(n): number = 1 for i in range(1, n + 1): number = int((number * i)/math.gcd(number, i)) return number n = int(input()) print (divisible_from_1_to_n(n)) INPUT 20 OUTPUT 232792560","title":"Smallest number evenly divisible by numbers from 1 to 20"},{"location":"problem-005/#smallest-number-evenly-divisible-by-numbers-from-1-to-20","text":"import math def divisible_from_1_to_n(n): number = 1 for i in range(1, n + 1): number = int((number * i)/math.gcd(number, i)) return number n = int(input()) print (divisible_from_1_to_n(n)) INPUT 20 OUTPUT 232792560","title":"Smallest number evenly divisible by numbers from 1 to 20"},{"location":"problem-018/","text":"Maximum Path Sum I # tri = \"\"\" 75 95 64 17 47 82 18 35 87 10 20 04 82 47 65 19 01 23 75 03 34 88 02 77 73 07 63 67 99 65 04 28 06 16 70 92 41 41 26 56 83 40 80 70 33 41 48 72 33 47 32 37 16 94 29 53 71 44 65 25 43 91 52 97 51 14 70 11 33 28 77 73 17 78 39 68 17 57 91 71 52 38 17 14 91 43 58 50 27 29 48 63 66 04 68 89 53 67 30 73 16 69 87 40 31 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23 \"\"\" myarr = [list(x.split()) for x in tri.strip().split('\\n')] possible_paths = [] max_len = len(myarr) def path_func(st, i, j, length): st.append(myarr[i][j]) if (length == max_len): possible_paths.append([int(x) for x in st]) # left recurse if (i+1 < max_len): path_func(st, i+1, j, length + 1) # right recurse if (i+1 < max_len and j < len(myarr[i+1])): path_func(st, i+1, j+1, length + 1) st.pop() path_func([], 0, 0, 1) max(list(map(lambda x: sum(x), possible_paths))) OUTPUT 1074","title":"Maximum Path Sum I"},{"location":"problem-018/#maximum-path-sum-i","text":"tri = \"\"\" 75 95 64 17 47 82 18 35 87 10 20 04 82 47 65 19 01 23 75 03 34 88 02 77 73 07 63 67 99 65 04 28 06 16 70 92 41 41 26 56 83 40 80 70 33 41 48 72 33 47 32 37 16 94 29 53 71 44 65 25 43 91 52 97 51 14 70 11 33 28 77 73 17 78 39 68 17 57 91 71 52 38 17 14 91 43 58 50 27 29 48 63 66 04 68 89 53 67 30 73 16 69 87 40 31 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23 \"\"\" myarr = [list(x.split()) for x in tri.strip().split('\\n')] possible_paths = [] max_len = len(myarr) def path_func(st, i, j, length): st.append(myarr[i][j]) if (length == max_len): possible_paths.append([int(x) for x in st]) # left recurse if (i+1 < max_len): path_func(st, i+1, j, length + 1) # right recurse if (i+1 < max_len and j < len(myarr[i+1])): path_func(st, i+1, j+1, length + 1) st.pop() path_func([], 0, 0, 1) max(list(map(lambda x: sum(x), possible_paths))) OUTPUT 1074","title":"Maximum Path Sum I"},{"location":"problem-020/","text":"Factorial Digit Sum # num = 100 prod = 1 for i in range(1, num+1): prod = prod * i sum([int(x) for x in list(str(prod))]) OUTPUT 648","title":"Factorial Digit Sum"},{"location":"problem-020/#factorial-digit-sum","text":"num = 100 prod = 1 for i in range(1, num+1): prod = prod * i sum([int(x) for x in list(str(prod))]) OUTPUT 648","title":"Factorial Digit Sum"},{"location":"problem-023/","text":"Non-Abundant Numbers # abun = [] for i in range(1, 28123): factors = [] for k in range(1, i//2+1): if i % k == 0: factors.append(k) if (sum(factors) > i): #print(i, factors) abun.append(i) combinations = [] for num1 in abun: for num2 in abun: if num1+num2 <= 28123: combinations.append(num1+num2) ab_com = set(combinations) sum(set(range(1, 28123+1)) - ab_com) OUTPUT 4179871","title":"Non-Abundant Numbers"},{"location":"problem-023/#non-abundant-numbers","text":"abun = [] for i in range(1, 28123): factors = [] for k in range(1, i//2+1): if i % k == 0: factors.append(k) if (sum(factors) > i): #print(i, factors) abun.append(i) combinations = [] for num1 in abun: for num2 in abun: if num1+num2 <= 28123: combinations.append(num1+num2) ab_com = set(combinations) sum(set(range(1, 28123+1)) - ab_com) OUTPUT 4179871","title":"Non-Abundant Numbers"},{"location":"problem-025/","text":"1000-digit Fibonacci number # a = 0 b = 1 idx = 1 while True: if (len(str(b))>= 1000): print(f'idx = {idx}, b = {b}, len = {len(str(b))}') break a, b = b, a + b idx += 1 OUTPUT idx = 4782, b = 1070066266382758936764980584457396885083683896632151665013235203375314520604694040621889147582489792657804694888177591957484336466672569959512996030461262748092482186144069433051234774442750273781753087579391666192149259186759553966422837148943113074699503439547001985432609723067290192870526447243726117715821825548491120525013201478612965931381792235559657452039506137551467837543229119602129934048260706175397706847068202895486902666185435124521900369480641357447470911707619766945691070098024393439617474103736912503231365532164773697023167755051595173518460579954919410967778373229665796581646513903488154256310184224190259846088000110186255550245493937113651657039447629584714548523425950428582425306083544435428212611008992863795048006894330309773217834864543113205765659868456288616808718693835297350643986297640660000723562917905207051164077614812491885830945940566688339109350944456576357666151619317753792891661581327159616877487983821820492520348473874384736771934512787029218636250627816, len = 1000","title":"1000-digit Fibonacci number"},{"location":"problem-025/#1000-digit-fibonacci-number","text":"a = 0 b = 1 idx = 1 while True: if (len(str(b))>= 1000): print(f'idx = {idx}, b = {b}, len = {len(str(b))}') break a, b = b, a + b idx += 1 OUTPUT idx = 4782, b = 1070066266382758936764980584457396885083683896632151665013235203375314520604694040621889147582489792657804694888177591957484336466672569959512996030461262748092482186144069433051234774442750273781753087579391666192149259186759553966422837148943113074699503439547001985432609723067290192870526447243726117715821825548491120525013201478612965931381792235559657452039506137551467837543229119602129934048260706175397706847068202895486902666185435124521900369480641357447470911707619766945691070098024393439617474103736912503231365532164773697023167755051595173518460579954919410967778373229665796581646513903488154256310184224190259846088000110186255550245493937113651657039447629584714548523425950428582425306083544435428212611008992863795048006894330309773217834864543113205765659868456288616808718693835297350643986297640660000723562917905207051164077614812491885830945940566688339109350944456576357666151619317753792891661581327159616877487983821820492520348473874384736771934512787029218636250627816, len = 1000","title":"1000-digit Fibonacci number"},{"location":"problem-031/","text":"Coins Sum # coins = [1, 2, 5, 10, 20, 50, 100, 200] target = 200 dp = [[1] + [0]*target for i in range(len(coins)+1)] for i in range(1, len(dp)): for j in range(1, target+1): dp[i][j] += dp[i-1][j] if (j-coins[i-1] >= 0): dp[i][j] += dp[i][j-coins[i-1]] dp[len(coins)][target] OUTPUT 73682 Recursive solution coins = [1, 2, 5, 10, 20, 50, 100, 200] def count_ways(coins, coins_available, target_amt): if target_amt == 0: return 1 if target_amt < 0 or coins_available <= 0: return 0 # either don't use the coin, the target_amt remains same # or use the coin, so the target_amt reduces by coin amount return count_ways(coins, coins_available-1, target_amt) + count_ways(coins, coins_available, target_amt - coins[coins_available-1]) count_ways(coins, len(coins), 200)","title":"Coins Sum"},{"location":"problem-031/#coins-sum","text":"coins = [1, 2, 5, 10, 20, 50, 100, 200] target = 200 dp = [[1] + [0]*target for i in range(len(coins)+1)] for i in range(1, len(dp)): for j in range(1, target+1): dp[i][j] += dp[i-1][j] if (j-coins[i-1] >= 0): dp[i][j] += dp[i][j-coins[i-1]] dp[len(coins)][target] OUTPUT 73682 Recursive solution coins = [1, 2, 5, 10, 20, 50, 100, 200] def count_ways(coins, coins_available, target_amt): if target_amt == 0: return 1 if target_amt < 0 or coins_available <= 0: return 0 # either don't use the coin, the target_amt remains same # or use the coin, so the target_amt reduces by coin amount return count_ways(coins, coins_available-1, target_amt) + count_ways(coins, coins_available, target_amt - coins[coins_available-1]) count_ways(coins, len(coins), 200)","title":"Coins Sum"},{"location":"problem-034/","text":"Digit Factorials # from functools import reduce facts = [1] + [reduce(lambda x, y: x * y, range(1, i+1)) for i in range(1, 10)] curi_num = lambda num: sum(map(lambda x: facts[int(x)], list(str(num)))) == num curi_nums = [i for i in range(1000000) if curi_num(i)] sum(set(curi_nums) - {1, 2}) OUTPUT 40730","title":"Digit Factorials"},{"location":"problem-034/#digit-factorials","text":"from functools import reduce facts = [1] + [reduce(lambda x, y: x * y, range(1, i+1)) for i in range(1, 10)] curi_num = lambda num: sum(map(lambda x: facts[int(x)], list(str(num)))) == num curi_nums = [i for i in range(1000000) if curi_num(i)] sum(set(curi_nums) - {1, 2}) OUTPUT 40730","title":"Digit Factorials"},{"location":"problem-038/","text":"Pandigital Multiples # from functools import reduce def concat_prod(x, l): return reduce(lambda x, y: x + y, [str(num * x) for num in l]) digitset = {'1', '2', '3', '4', '5', '6', '7', '8', '9'} pandigitalnums = [(int(concat_prod(x, l)), x) for x in range(9000, 9999) if set(concat_prod(x, l)) == digitset] pandigitalnums OUTPUT [(926718534, 9267), (927318546, 9273), (932718654, 9327)] 932718654","title":"Pandigital Multiples"},{"location":"problem-038/#pandigital-multiples","text":"from functools import reduce def concat_prod(x, l): return reduce(lambda x, y: x + y, [str(num * x) for num in l]) digitset = {'1', '2', '3', '4', '5', '6', '7', '8', '9'} pandigitalnums = [(int(concat_prod(x, l)), x) for x in range(9000, 9999) if set(concat_prod(x, l)) == digitset] pandigitalnums OUTPUT [(926718534, 9267), (927318546, 9273), (932718654, 9327)] 932718654","title":"Pandigital Multiples"}]}